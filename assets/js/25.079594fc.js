(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{372:function(t,e,a){"use strict";a.r(e);var n=a(42),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("2017-12-31 12:49，发布于博客园")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/isLiu/p/8157463.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/isLiu/p/8157463.html"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("现在我们的Redux和React-Redux已经基本实现了，在Redux中，触发一个action，reducer立即就能算出相应的state，如果我要过一会才让reducer计算state呢怎么办？也就是我们如何实现异步的action呢？这里就要用到中间件（middleware）")]),t._v(" "),a("h2",{attrs:{id:"_1-中间件（middleware）介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-中间件（middleware）介绍"}},[t._v("#")]),t._v(" 1. 中间件（middleware）介绍")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("中间就是在action与reducer之间又加了一层，没有中间件的Redux的过程是："),a("code",[t._v("action -> reducer")]),t._v("，而有了中间件的过程就是"),a("code",[t._v("action -> middleware -> reducer")]),t._v("，使用中间件我们可以对action也就是对dispatch方法进行装饰，我们可以用它来实现异步action、打印日志、错误报告等功能。")]),t._v(" "),a("p",[t._v("又是装饰器，没错，这块的好多东西都离不开装饰器模式，所以，设计模式很重要。")]),t._v(" "),a("p",[t._v("关于中间件，有很多框架或者是类库都使用了中间件，像express、koa、mongoose等都有使用。")]),t._v(" "),a("h2",{attrs:{id:"_2-redux中间件的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-redux中间件的使用"}},[t._v("#")]),t._v(" 2. Redux中间件的使用")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("我们可以使用Redux提供的applyMiddleware方法来使用一个或者是多个中间件，将它作为createStore的第二个参数传入即可，我们以Redux-Thunk为例")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\n\nconst store = createStore(counter, applyMiddleware(thunk))\nReactDOM.render(\n  (\n    <Provider store={store}>\n      <App />\n    </Provider>\n  ),\n  document.getElementById('root')\n)\n")])])]),a("p",[t._v("通过thunk中间件，我们就可以实现异步的action了。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export function addAsync(){\n  return dispatch => {\n    setTimeout(() => {\n      dispatch(add())\n    }, 2000);\n  }\n}\n")])])]),a("p",[t._v("想要实现中间件，我们首先有两个任务要做：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("扩展createStore方法，使它可以接收第二个参数。")])]),t._v(" "),a("li",[a("p",[t._v("applyMiddleware方法的实现。")])])]),t._v(" "),a("h2",{attrs:{id:"_3-createstore方法的扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-createstore方法的扩展"}},[t._v("#")]),t._v(" 3. createStore方法的扩展")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("我们在createStore中加入第二个参数enhancer, 专业的解释应该叫增强器，叫middleware也可以的。")]),t._v(" "),a("p",[t._v("我们已经说过中间件的作用就是通过改变dispatch方法来改变数据流，所以我们这里直接用enhancer对createStore方法进行装饰。Redux的源码也是这么写的，哈哈哈哈，怎么和我想到的一模一样呢？因为我看了Redux的源码。。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export function createStore (reducer，enhancer) {\n  if (enhancer) {\n    return enhancer(createStore)(reducer)\n  }\n  let state = {}\n  let listeners = []\n\n  function getState () {\n    return state\n  }\n  function subscribe (listener) {\n    listeners.push(listener)\n  }\n  function dispatch (action) {\n    state = reducer(state, action)\n    listeners.forEach(listener => listener())\n    return action\n  }\n\n  dispatch({type: '@myRedux'})\n  return {getState, subscribe, dispatch}\n}\n")])])]),a("p",[t._v("高阶函数的写法，应该都能看懂了吧？前几篇随笔有详细的讲高阶函数，还有例子。")]),t._v(" "),a("h2",{attrs:{id:"_4-applymiddleware方法的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-applymiddleware方法的实现"}},[t._v("#")]),t._v(" 4.applyMiddleware方法的实现")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("先看我们上边对enhancer的调用，enhancer也就是我们的applyMiddleware接受了createStore做参数，返回了一个函数，这个函数的参数是reducer。现在我们对这种两层嵌套的函数已经不陌生了，其实它就是一个return两层的函数。")]),t._v(" "),a("p",[t._v("我们的applyMiddleware主要做了什么呢？首先通过传入的createStore方法create了一个store，然后将store的dispatch传递给middleware，由middleware对dispatch进行包装，返回一个带有被包装的dispatch的store。")]),t._v(" "),a("p",[t._v("看到这里，很简单嘛。但是注意，还记得我们是怎么使用异步的action的吗？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export function addAsync(){\n  return (dispatch, getState) => {\n    setTimeout(() => {\n      dispatch(add())\n    }, 2000);\n  }\n}\n")])])]),a("p",[t._v("居然还可以在可以在异步的action中拿到dispatch和getState方法，所以要对这个进行处理，也不是很难，把他俩传给我们的middle就好了。")]),t._v(" "),a("p",[t._v("都说到这里了，能不能自己写出来呢？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export function applyMiddleware (middleware){\n\treturn createStore => (...args) => {\n\t\tconst store = createStore(...args)\n\t\tlet dispatch = store.dispatch\n\n\t\tconst midApi = {\n\t\t\tgetState: store.getState,\n\t\t\tdispatch: (...args)=>dispatch(...args)\n\t\t}\n\t\tdispatch = middleware(midApi)(store.dispatch)\n\t\treturn {\n\t\t\t...store,\n\t\t\tdispatch\n\t\t}\n\t}\n}\n")])])]),a("p",[t._v("如果我们执行了被包装后的dispatch，就相当于执行了"),a("code",[t._v("middleware(midApi)(store.dispatch)(action)")]),t._v("这段语句，这是一个三层的嵌套函数，我们也称作柯里化。")]),t._v(" "),a("h2",{attrs:{id:"_5-自己的redux-thunk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-自己的redux-thunk"}},[t._v("#")]),t._v(" 5.自己的redux-thunk")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("其实自己的thunk很简单，正常的action的的返回值是个对象，前面已经说过，异步的action的返回值是一个函数，那么我们只需要判断一下action的返回的类型即可。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const thunk = ({dispatch, getState}) => next => action => {\n\tif (typeof action === 'function') {\n\t\treturn action(dispatch, getState)\n\t}\n\treturn next(action)\n}\n\nexport thunk\n")])])]),a("p",[t._v("在这里呢，dispatch和getState就是我们在applyMiddleware中传入的那个midApi对象，next就是store.dispatch也可以理解为下一个中间件，如果action的类型是object，说明这是一个同步的，直接dispatch就好了，如果\naction的类型是function，当触发这个dispatch的时候，就触发action这个函数，同时将dispatch和getState方法传入到action函数中，这也是为什么我们能在异步action中拿到dispatch和getState方法的原因。")]),t._v(" "),a("h2",{attrs:{id:"_6-多个中间件合并与compose方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-多个中间件合并与compose方法"}},[t._v("#")]),t._v(" 6.多个中间件合并与compose方法")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("我们的applyMiddle方法还不是太完善，只能使用一个中间件，使用多个中间件怎么办，这个，简单，map一下呗。如果是要求多个中间件依此执行怎么办？还是map呀，好，来map一下。")]),t._v(" "),a("p",[t._v("我们会得到这样的代码：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const store = createStore(\n    reducer,\n    applyMiddleware(middlewareOne) (\n        middlewareTwo(\n          middlewareThree(\n              ...\n          )\n        )\n    )\n)\n")])])]),a("p",[t._v("我们会发现，我们陷入了一个深度嵌套的函数当中，这时我们就需要一个compose方法来结合一下，方便我们的书写。")]),t._v(" "),a("p",[t._v("compose是函数式编程的一种写法，compose的作用是从右到左结合多个函数，形成一个最终函数。就是将"),a("code",[t._v("fn1(fn2(fn3()))")]),t._v("的形式，变成compose(fn1, fn2, fn3)的形式。")]),t._v(" "),a("p",[t._v("compose 做的只是让你在写深度嵌套的函数时，避免了代码的向右偏移。不要觉得它很复杂。")]),t._v(" "),a("p",[t._v("compose方法的实现：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export function compose (...funcs){\n\tif (funcs.length==0) {\n\t\treturn arg=>arg\n\t}\n\tif (funcs.length==1) {\n\t\treturn funcs[0]\n\t}\n\treturn funcs.reduce((ret,item)=> (...args)=>{\n\t\t\t\tconsole.log(ret)\n       return ret(item(...args))\n      })\n}\n")])])]),a("p",[t._v("compose不是那么复杂，关于如果想了解更多关于compose的知识，可以看看"),a("a",{attrs:{href:"http://cn.redux.js.org/docs/api/compose.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux对compose的说明"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("到这里我们可以使用多个中间件的applyMiddleware方法已经实现了，整个的applyMiddleware方法在这里：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export function applyMiddleware (...middlewares){\n\treturn createStore=>(...args)=>{\n\t\tconst store = createStore(...args)\n\t\tlet dispatch = store.dispatch\n\n\t\tconst midApi = {\n\t\t\tgetState:store.getState,\n\t\t\tdispatch:(...args)=>dispatch(...args)\n\t\t}\n\t\tconst middlewareChain = middlewares.map(middleware=>{\n\t\t\treturn middleware(midApi)\n\t\t})\n\t\tconsole.log(compose(...middlewareChain)(store.dispatch))\n\t\tdispatch = compose(...middlewareChain)(store.dispatch)\n\t\treturn {\n\t\t\t...store,\n\t\t\tdispatch\n\t\t}\n\t}\n}\nexport function compose(...funcs){\n\tif (funcs.length==0) {\n\t\treturn arg=>arg\n\t}\n\tif (funcs.length==1) {\n\t\treturn funcs[0]\n\t}\n\treturn funcs.reduce((ret,item)=> (...args)=>{\n\t\t\t\tconsole.log(ret)\n       return ret(item(...args))\n      })\n}\n")])])]),a("p",[t._v("到这里，整个Redux和React-Redux的基本原理我们已经清楚了，也已经基本实现了，发现其中涉及到很多函数式编程和装饰者模式，还有一次观察者模式，所以，编程思想和设计模式是很重要的，有时间一定要加强这方面的学习。")]),t._v(" "),a("p",[t._v("我们现在有了这些基础，可以去看看Redux和React-Redux的源码，也大体上和我写的是差不多的，因为我也看了源码。")])])}),[],!1,null,null,null);e.default=r.exports}}]);