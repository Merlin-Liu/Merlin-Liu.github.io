(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{359:function(n,e,t){"use strict";t.r(e);var r=t(42),a=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[n._v("TIP")]),n._v(" "),t("p",[n._v("2018-01-22 14:29，发布于博客园")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/isLiu/p/8328533.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.cnblogs.com/isLiu/p/8328533.html"),t("OutboundLink")],1)])]),n._v(" "),t("p",[n._v("二叉树是一种很重要的数据结构，对于二叉树的遍历，有深度优先遍历和广度优先遍历，深度优先遍历又有先序、中序、后续遍历，广度优先遍历就是按层遍历。")]),n._v(" "),t("h2",{attrs:{id:"_1-深度优先遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-深度优先遍历"}},[n._v("#")]),n._v(" 1. 深度优先遍历")]),n._v(" "),t("hr"),n._v(" "),t("p",[n._v("深度优先遍历，也就是先序、中序、后续遍历，我之前有一篇随笔已经说的很清楚了，在这里我只贴下代码就好了。")]),n._v(" "),t("p",[n._v("传送门："),t("a",{attrs:{href:"http://www.cnblogs.com/isLiu/p/7919856.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("详细教你实现BST(二叉排序树)"),t("OutboundLink")],1)]),n._v(" "),t("p",[n._v("在这里我依然用之前建立好的Node、Stack、BST结构来实现代码。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Node {\n  constructor(data, leftNode, rightNode) {\n    this.data = data\n    this.leftNode = leftNode\n    this.rightNode = rightNode\n  }\n  print () {\n    return this.data\n  }\n}\n\nclass Stack {\n  constructor() {\n    this.arr = []\n  }\n  pop () {\n    return this.arr.shift()\n  }\n  push (data) {\n    this.arr.unshift(data)\n  }\n  isEmpty () {\n    return this.arr.length == 0\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null\n  }\n  insert (data) {...}\n  preOrder () {...}\n  inOrder () {...}\n  postOrder () {...}\n  ...\n}\n")])])]),t("p",[n._v("先是先序、中序、后序遍历的递归实现，很简单。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 递归先序\nfunction preOrderFn (node) {\n  if (node) {\n    console.log(node.print())\n    preOrderFn(node.leftNode)\n    preOrderFn(node.rightNode)\n  }\n}\n\n// 递归中序\nfunction inOrderFn (node) {\n  if (node) {\n    inOrderFn(node.leftNode)\n    console.log(node.print())\n    inOrderFn(node.rightNode)\n  }\n}\n\n// 递归后续\nfunction postOrderFn (node) {\n  if (node) {\n    postOrderFn (node.leftNode)\n    postOrderFn (node.rightNode)\n    console.log(node.print())\n  }\n}\n")])])]),t("p",[n._v("然后就是先序、中序、后续遍历的非递归实现了。详细的解释和说明，点击上面的传送门就有了，这里不过多赘述。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 非递归先序\nfunction PreOrderWithoutRecursion (root) {\n  if (!root)\n    return\n\n  var parentNode = root\n  var stack = new Stack()\n\n  while (parentNode || !stack.isEmpty()) {\n\n    // 一直遍历到左子树的最下面，一边打印data,将一路遍历过的节点push进栈中\n    if (parentNode) {\n      console.log(parentNode.data)\n      stack.push(parentNode)\n      parentNode = parentNode.leftNode\n    }\n    // 当parentNode为空时，说明已经达到了左子树的最下面，可以出栈操作了\n    else {\n      parentNode = stack.pop()\n      // 进入右子树，开始新一轮循环\n      parentNode = parentNode.rightNode\n    }\n  }\n}\n\n// 非递归中序\nfunction inOrderWithoutRecursion (root) {\n  if (!root)\n    return\n\n  var parentNode = root\n  var stack = new Stack()\n\n  while (parentNode || !stack.isEmpty()) {\n\n    // 一直遍历到左子树的最下面，将一路遍历过的节点push进栈中\n    if (parentNode) {\n      stack.push(parentNode)\n      parentNode = parentNode.leftNode\n    }\n    // 当parentNode为空时，说明已经达到了左子树的最下面，可以出栈操作了\n    else {\n      parentNode = stack.pop()\n      console.log(parentNode.data)\n      // 进入右子树，开始新一轮循环\n      parentNode = parentNode.rightNode\n    }\n  }\n}\n\n// 非递归后续\nfunction PostOrderWithoutRecursion (root) {\n  if (!root)\n    return\n\n  var parentNode = root\n  var stack = new Stack()\n  var lastVisitNode = null\n\n  while (parentNode || !stack.isEmpty()) {\n    if (parentNode) {\n      stack.push(parentNode)\n      parentNode = parentNode.leftNode\n    }\n    else {\n      parentNode = stack.pop()\n      // 如果当前节点没有右节点或者是右节点被访问过，则访问当前节点\n      if (!parentNode.rightNode || parentNode.rightNode.data == lastVisitNode.data) {\n        console.log(parentNode.data)\n        lastVisitNode = parentNode\n      }\n      // 访问右节点\n      else {\n        stack.push(parentNode)\n        parentNode = parentNode.rightNode\n        while (parentNode) {\n          parentNode = parentNode.leftNode\n        }\n      }\n    }\n  }\n}\n")])])]),t("h2",{attrs:{id:"_2-广度优先遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-广度优先遍历"}},[n._v("#")]),n._v(" 2. 广度优先遍历")]),n._v(" "),t("hr"),n._v(" "),t("p",[n._v("其实这片随笔有点打酱油了，只说了两个遍历，还有一个是在以前实现过的。")]),n._v(" "),t("p",[n._v("广度优先遍历，顾名思义，就是横向先遍历，也就是按层次遍历，从根节点往下，对每一层依此访问，在每一层中从左到右（也可以从右到左）遍历，遍历完一层就进入下一层，直到没有节点。")]),n._v(" "),t("p",[n._v("之前讲深度优先非递归遍历的时候，我们用到了一个栈的数据结构，到了广度优先遍历的时候，我们就要用到队列这个数据结构。")]),n._v(" "),t("p",[n._v("为什么上一次用栈，这一次就要用到队列了呢？")]),n._v(" "),t("p",[n._v("拿非递归中序遍历举例，我们每遍历到一个节点就要进行入栈操作，遍历完左节点之后，还需要找到根节点，再通过根节点找到右节点，所以我们需要最后遍历到的节点在这个数据结构的最顶端，这不就是栈吗？")]),n._v(" "),t("p",[n._v("先把我们的队列的数据结构先建立起来再说。依然用数组模拟队列的操作。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Queue {\n  constructor () {\n    this.arr = []\n  }\n  enqueue (data) {\n    return this.arr.push(data)\n  }\n  dequeue () {\n    return this.arr.shift()\n  }\n  isEmpty () {\n    return this.arr.length == 0\n  }\n}\n")])])]),t("p",[n._v("为什么要用队列呢，我们按层次遍历，首先遍历根节点，然后左子树，右子树，然后左子树的左子树，左子树的右子树，右子树的左子树，依此类推。每遍历到一个节点，就将它存在一个数据结构里，先把它的前面的节点遍历完，才能遍历它，也就是一个先进先出（FIFO）的遍历方式，这不就是队列吗？")]),n._v(" "),t("p",[n._v("说下思路：首先现将根节点做入队操作，队列里的节点表示我们要遍历的节点，所以队列为空的时候也就是没有节点可以遍历了，即队列不为空的时候循环遍历整个队列。首先我们取出队列的第一个节点，也就是对这个队列做出队操作，访问这个节点的值，如果这个节点存在左子树，那么将它的左子树放在队列的末尾，也就是对左子树做入队操作，右子树同理。")]),n._v(" "),t("p",[n._v("思路很简单，实现起来不难：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class BST {\n  constructor() {\n    this.root = null\n  }\n  // 广度优先遍历\n  levelOrderTraversal () {\n    levelOrderTraversalFn(this.root)\n  }\n  insert (data) {...}\n  preOrder () {...}\n  inOrder () {...}\n  postOrder () {...}\n  find (data) {..}\n  getMax () {...}\n  getMin () {...}\n  deleteNode (data) {...}\n  depth () {...}\n  nodeCount () {...}\n}\n\n// 广度优先遍历\nfunction levelOrderTraversalFn (node) {\n  if(!node) {\n    return\n  }\n\n  var que = new Queue()\n  que.enqueue(node)\n  while(!que.isEmpty()) {\n    node = que.dequeue()\n    console.log(node.data)\n    if(node.leftNode) que.enqueue(node.leftNode)\n    if(node.rightNode) que.enqueue(node.rightNode)\n  }\n}\n")])])]),t("p",[n._v("我们试一下：")]),n._v(" "),t("p",[t("img",{attrs:{src:"http://images2017.cnblogs.com/blog/1272362/201801/1272362-20180122142255881-1751878691.png",alt:""}})]),n._v(" "),t("p",[n._v("没错，那我们的广度优先遍历也就写完了。")])])}),[],!1,null,null,null);e.default=a.exports}}]);