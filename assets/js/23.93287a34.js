(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{369:function(t,e,n){"use strict";n.r(e);var r=n(42),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),n("p",[t._v("2017-12-26 20:07，发布于博客园")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/isLiu/p/8117427.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/isLiu/p/8117427.html"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("react使用redux做状态管理，实现多个组件之间的信息共享，解决了父子组件、兄弟组件之间的复杂通信问题。vue有vuex，总之是一种flux的思想。react提供了react-redux这个库，一看名字就知道是为了将react和redux关联起来，react-redux有connect高阶函数以及Provider组件、milddleware、thunk等，来实现一下。")]),t._v(" "),n("p",[t._v("篇幅过长，多分了几篇。")]),t._v(" "),n("h2",{attrs:{id:"_1-redux简单实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-redux简单实现"}},[t._v("#")]),t._v(" 1. Redux简单实现")]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("这里先不考虑中间件机制")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { createStore } from 'redux'\n\nfunction counter(state = 10, action) {\n  console.log(state, action)\n  switch (action.type) {\n    case 'add':\n      return state + 1\n    case 'less':\n      return state - 1\n    default:\n      return state\n  }\n}\n\nconst store = createStore(counter)\n\nconst init = store.getState()\nconsole.log(`Init count: ${init}`)\n\nfunction listener(){\n  const current = store.getState()\n  console.log(`count: ${current}`)\n}\nstore.subscribe(listener)\n\nstore.dispatch({ type: 'add' })\nstore.dispatch({ type: 'less' })\n")])])]),n("p",[t._v("这是redux简单的例子，首先我们定义了一个reducer叫做counter，接下来使用redux提供的createStore方法将reducer传入，构造出了一个store，然后基于观察者模式，触发相应的action，进行相应的响应。")]),t._v(" "),n("p",[t._v("Redux重点的方法就是createStore、getState、subscribe、dispatch这四个方法。大体讲一下思路，我们的Redux，这里就叫myRedux，myRedux和Redux一样，都是只暴露出来一个方法，那就是createStore，然后createStore保存着一个state，可以是对象、字符串、数组等，可以通过getState方法来访问state，还有对state的监听器以及订阅的方法，实现一下。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export function createStore (reducer) {\n  let state = {}\n  let listeners = []\n\n  function getState () {\n    return state\n  }\n  function subscribe (listener) {\n    listeners.push(listener)\n  }\n  function dispatch (action) {\n    state = reducer(state, action)\n    listeners.forEach(listener => listener())\n    return action\n  }\n  // 为了确保createStore之后，store.getState中就有state的初始值\n  dispatch({type: '@myRedux/qwe'})\n  return {getState, subscribe, dispatch}\n}\n")])])]),n("p",[t._v("其实就是一个观察者模式，值得注意的是：当执行完createStore之后，执行stroe.getState方法就能获取到初始的状态(我们这里是10)，所以需要我们的reducer先执行一次，那么我们就要在createStore中就先dispatch一下，代码中有体现。Redux中也是这么做的，Redux初始化dispatch的type值是"),n("code",[t._v("@@redux/INIT")]),t._v("，可以看一下。")]),t._v(" "),n("p",[n("img",{attrs:{src:"http://images2017.cnblogs.com/blog/1272362/201712/1272362-20171226183309432-211313656.png",alt:""}})]),t._v(" "),n("p",[t._v("这么做是为了确保初始化dispatch的type值不会和用户定义的type值重复，我们代码里type为"),n("code",[t._v("@myRedux/qwe")]),t._v("。")]),t._v(" "),n("h2",{attrs:{id:"_2-react中的context"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-react中的context"}},[t._v("#")]),t._v(" 2.react中的context")]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("要理解react-redux原理，必须先说下react中的context。父组件向子组件传递数据，可以通过props，如果层级比较深呢？就不好了，会有性能问题，我们可以通过context来实现跨级传递数据。")]),t._v(" "),n("p",[t._v("context是全局的，在组件中声明，所有的子组件都可以获取到context，react觉得全局不是很安全，所以要求context都是强数据类型，即任何想访问context里面的属性的组件都必须指定一个"),n("code",[t._v("contextTypes")]),t._v("的属性，如果没有指定该属性的话，用"),n("code",[t._v("this.context")]),t._v("访该属性就会出错。")]),t._v(" "),n("p",[t._v("同样，通过"),n("code",[t._v("getChildContext")]),t._v("方法指定传递给子组件的属性也需要被指定数据类型，通过childContextTypes来指定，不指定同样会产生错误。")]),t._v(" "),n("p",[t._v("下面是一个简单例子。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass Son extends React.Component{\n\trender(){\n\t\t\treturn (\n\t\t\t\t<div>\n\t\t\t\t\t<p>子组件</p>\n\t\t\t\t\t<GrandSon/>\n\t\t\t\t</div>\n\t\t\t)\n\t}\n}\n\nclass GrandSon extends React.Component{\n\tstatic contextTypes = {\n\t\tuser:PropTypes.string\n\t}\n\trender(){\n\t\tconsole.log(this.context)\n\t\treturn (\n\t\t\t\t<div>\n\t\t\t\t\t<p>孙组件</p>\n\t\t\t\t\t<div>孙组件收到来自父组件的信息：{this.context.user}</div>\n\t\t\t\t</div>\n\t\t)\n\t}\n}\n\nclass Father extends React.Component{\n\tstatic childContextTypes = {\n\t\tuser:PropTypes.string\n\t}\n\tconstructor(props){\n\t\tsuper(props)\n\t\tthis.state = {user:'user12'}\n\t}\n\tgetChildContext(){\n\t\treturn this.state\n\t}\n\trender(){\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<p>父组件，要给孙组件:{this.state.user}</p>\n\t\t\t\t<Son/>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default Father\n")])])]),n("p",[t._v("在这里就不需要通过props一层一层的往下传递属性了，这就是context。")]),t._v(" "),n("h2",{attrs:{id:"_3-provider组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-provider组件"}},[t._v("#")]),t._v(" 3.Provider组件")]),t._v(" "),n("hr"),t._v(" "),n("p",[t._v("那么context和我们的react-redux有什么关系呢，用过的都知道，Provider组件在整个应用组件上包了一层，让整个应用组件成为Provider的子组件，看到这里，你是不是有点懂了，跟上面的例子很像嘛，对的，就是这样，我们的Provider组件接收Redux的store作为props，通过context对象传递给子组件。")]),t._v(" "),n("p",[t._v("我们下一篇就会说道Provider组件。")])])}),[],!1,null,null,null);e.default=s.exports}}]);