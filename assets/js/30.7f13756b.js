(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{376:function(n,e,o){"use strict";o.r(e);var d=o(42),t=Object(d.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[n._v("TIP")]),n._v(" "),o("p",[n._v("2017-11-28 16:50，发布于博客园")]),n._v(" "),o("p",[o("a",{attrs:{href:"https://www.cnblogs.com/isLiu/p/7909889.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.cnblogs.com/isLiu/p/7909889.html"),o("OutboundLink")],1)])]),n._v(" "),o("p",[n._v("DOM“天生就慢”，所以前端各大框架都提供了对DOM操作进行优化的办法，Angular中的是"),o("font",{attrs:{color:"red"}},[n._v("脏值检查")]),n._v("，React首先提出了"),o("font",{attrs:{color:"red"}},[n._v("Virtual Dom")]),n._v("，Vue2.0也加入了"),o("font",{attrs:{color:"red"}},[n._v("Virtual Dom")]),n._v("，与React类似。")],1),n._v(" "),o("p",[n._v("本文将对于Vue 2.5.3版本中使用的"),o("font",{attrs:{color:"red"}},[n._v("Virtual Dom")]),n._v("进行分析。")],1),n._v(" "),o("p",[o("font",{attrs:{color:"red"}},[n._v("updataChildren")]),n._v("是Diff算法的核心，所以本文对"),o("font",{attrs:{color:"red"}},[n._v("updataChildren")]),n._v("进行了图文的分析。")],1),n._v(" "),o("h2",{attrs:{id:"_1-vnode对象"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-vnode对象"}},[n._v("#")]),n._v(" 1.VNode对象")]),n._v(" "),o("hr"),n._v(" "),o("p",[n._v("一个VNode的实例包含了以下属性，这部分代码在"),o("font",{attrs:{color:"red"}},[n._v("src/core/vdom/vnode.js")]),n._v("里")],1),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("export default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array<VNode>;\n  text: string | void;\n  elm: Node | void;\n  ns: string | void;\n  context: Component | void; // rendered in this component's scope\n  key: string | number | void;\n  componentOptions: VNodeComponentOptions | void;\n  componentInstance: Component | void; // component instance\n  parent: VNode | void; // component placeholder node\n\n  // strictly internal\n  raw: boolean; // contains raw HTML? (server only)\n  isStatic: boolean; // hoisted static node\n  isRootInsert: boolean; // necessary for enter transition check\n  isComment: boolean; // empty comment placeholder?\n  isCloned: boolean; // is a cloned node?\n  isOnce: boolean; // is a v-once node?\n  asyncFactory: Function | void; // async component factory function\n  asyncMeta: Object | void;\n  isAsyncPlaceholder: boolean;\n  ssrContext: Object | void;\n  functionalContext: Component | void; // real context vm for functional nodes\n  functionalOptions: ?ComponentOptions; // for SSR caching\n  functionalScopeId: ?string; // functioanl scope id support\n\n")])])]),o("ul",[o("li",[n._v("tag: 当前节点的标签名")]),n._v(" "),o("li",[n._v("data: 当前节点的数据对象，具体包含哪些字段可以参考vue源码types/vnode.d.ts中对VNodeData的定义")]),n._v(" "),o("li",[n._v("children: 数组类型，包含了当前节点的子节点")]),n._v(" "),o("li",[n._v("text: 当前节点的文本，一般文本节点或注释节点会有该属性")]),n._v(" "),o("li",[n._v("elm: 当前虚拟节点对应的真实的dom节点")]),n._v(" "),o("li",[n._v("ns: 节点的namespace")]),n._v(" "),o("li",[n._v("context: 编译作用域")]),n._v(" "),o("li",[n._v("functionalContext: 函数化组件的作用域")]),n._v(" "),o("li",[n._v("key: 节点的key属性，用于作为节点的标识，有利于patch的优化")]),n._v(" "),o("li",[n._v("componentOptions: 创建组件实例时会用到的选项信息")]),n._v(" "),o("li",[n._v("child: 当前节点对应的组件实例")]),n._v(" "),o("li",[n._v("parent: 组件的占位节点")]),n._v(" "),o("li",[n._v("raw: raw html")]),n._v(" "),o("li",[n._v("isStatic: 静态节点的标识")]),n._v(" "),o("li",[n._v("isRootInsert: 是否作为根节点插入，被"),o("code",[n._v("<transition>")]),n._v("包裹的节点，该属性的值为false")]),n._v(" "),o("li",[n._v("isComment: 当前节点是否是注释节点")]),n._v(" "),o("li",[n._v("isCloned: 当前节点是否为克隆节点")]),n._v(" "),o("li",[n._v("isOnce: 当前节点是否有v-once指令")])]),n._v(" "),o("h2",{attrs:{id:"_2-vnode的分类"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-vnode的分类"}},[n._v("#")]),n._v(" 2.VNode的分类")]),n._v(" "),o("hr"),n._v(" "),o("p",[n._v("VNode可以理解为Vue"),o("font",{attrs:{color:"red"}},[n._v("Virtual Dom")]),n._v("的一个基类，通过VNode构造函数生成的VNnode实例可为如下几类：")],1),n._v(" "),o("ul",[o("li",[n._v("EmptyVNode: 没有内容的注释节点")]),n._v(" "),o("li",[n._v("TextVNode: 文本节点")]),n._v(" "),o("li",[n._v("ElementVNode: 普通元素节点")]),n._v(" "),o("li",[n._v("ComponentVNode: 组件节点")]),n._v(" "),o("li",[n._v("CloneVNode: 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true")])]),n._v(" "),o("h2",{attrs:{id:"_3-create-element源码解析"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-create-element源码解析"}},[n._v("#")]),n._v(" 3.Create-Element源码解析")]),n._v(" "),o("hr"),n._v(" "),o("p",[n._v("这部分代码在"),o("font",{attrs:{color:"red"}},[n._v("src/core/vdom/create-element.js")]),n._v("里，我就直接粘代码加上我的注释了")],1),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("export function createElement (\n  context: Component,\n  tag: any,\n  data: any,\n  children: any,\n  normalizationType: any,\n  alwaysNormalize: boolean\n): VNode {\n  // 兼容不传data的情况\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children\n    children = data\n    data = undefined\n  }\n  // 如果alwaysNormalize是true\n  // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE\n  }\n  // 调用_createElement创建虚拟节点\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nexport function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode {\n\n  /**\n   * 如果存在data.__ob__，说明data是被Observer观察的数据\n   * 不能用作虚拟节点的data\n   * 需要抛出警告，并返回一个空节点\n   *\n   * 被监控的data不能被用作vnode渲染的数据的原因是：\n   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作\n   */\n  if (isDef(data) && isDef((data: any).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n      'Always create fresh vnode data objects in each render!',\n      context\n    )\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is\n  }\n  if (!tag) {\n    // 当组件的is属性被设置为一个falsy的值\n    // Vue将不会知道要把这个组件渲染成什么\n    // 所以渲染一个空节点\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // key为非原始值警告\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    warn(\n      'Avoid using non-primitive value as key, ' +\n      'use string/number value instead.',\n      context\n    )\n  }\n  // 作用域插槽\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {}\n    data.scopedSlots = { default: children[0] }\n    children.length = 0\n  }\n  // 根据normalizationType的值，选择不同的处理方法\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n  }\n  let vnode, ns\n  // 如果标签名是字符串类型\n  if (typeof tag === 'string') {\n    let Ctor\n    // 获取标签的命名空间\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    // 如果是保留标签\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      // 就创建这样一个vnode\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      )\n      // 如果不是保留字标签，尝试从vm的components上查找是否有这个标签的定义\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      // 如果找到，就创建虚拟组件节点\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      // 兜底方案，创建一个正常的vnode\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      )\n    }\n  } else {\n    // 当tag不是字符串的时候，我们认为tag是组件的构造类\n    // 所以直接创建\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  if (isDef(vnode)) {\n    // 应用命名空间\n    if (ns) applyNS(vnode, ns)\n    return vnode\n  } else {\n    // 返回一个空节点\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined\n    force = true\n  }\n  if (isDef(vnode.children)) {\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const child = vnode.children[i]\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {\n        applyNS(child, ns, force)\n      }\n    }\n  }\n}\n")])])]),o("h2",{attrs:{id:"_4-patch原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-patch原理"}},[n._v("#")]),n._v(" 4.Patch原理")]),n._v(" "),o("hr"),n._v(" "),o("p",[n._v("patch函数的定义在"),o("font",{attrs:{color:"red"}},[n._v("src/core/vdom/patch.js")]),n._v("中，patch逻辑比较简单，就不粘代码了")],1),n._v(" "),o("p",[n._v("patch函数接收6个参数：")]),n._v(" "),o("ul",[o("li",[n._v("oldVnode: 旧的虚拟节点或旧的真实dom节点")]),n._v(" "),o("li",[n._v("vnode: 新的虚拟节点")]),n._v(" "),o("li",[n._v("hydrating: 是否要跟真是dom混合")]),n._v(" "),o("li",[n._v("removeOnly: 特殊flag，用于"),o("code",[n._v("<transition-group>")]),n._v("组件")]),n._v(" "),o("li",[n._v("parentElm: 父节点")]),n._v(" "),o("li",[n._v("refElm: 新节点将插入到refElm之前")])]),n._v(" "),o("h3",{attrs:{id:"patch的逻辑是："}},[o("a",{staticClass:"header-anchor",attrs:{href:"#patch的逻辑是："}},[n._v("#")]),n._v(" patch的逻辑是：")]),n._v(" "),o("ol",[o("li",[o("p",[n._v("if vnode不存在但是oldVnode存在，说明意图是要销毁老节点，那么就调用invokeDestroyHook(oldVnode)来进行销")])]),n._v(" "),o("li",[o("p",[n._v("if oldVnode不存在但是vnode存在，说明意图是要创建新节点，那么就调用createElm来创建新节点")])]),n._v(" "),o("li",[o("p",[n._v("else 当vnode和oldVnode都存在时")]),n._v(" "),o("ul",[o("li",[n._v("if oldVnode和vnode是同一个节点，就调用patchVnode来进行patch")]),n._v(" "),o("li",[n._v("当vnode和oldVnode不是同一个节点时，如果oldVnode是真实dom节点或hydrating设置为true，需要用hydrate函数将虚拟dom和真是dom进行映射，然后将oldVnode设置为对应的虚拟dom，找到oldVnode.elm的父节点，根据vnode创建一个真实dom节点并插入到该父节点中oldVnode.elm的位置")])])])]),n._v(" "),o("h3",{attrs:{id:"patchvnode的逻辑是："}},[o("a",{staticClass:"header-anchor",attrs:{href:"#patchvnode的逻辑是："}},[n._v("#")]),n._v(" patchVnode的逻辑是：")]),n._v(" "),o("ol",[o("li",[o("p",[n._v("如果oldVnode跟vnode完全一致，那么不需要做任何事情")])]),n._v(" "),o("li",[o("p",[n._v("如果oldVnode跟vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上，也不用再有其他操作")])]),n._v(" "),o("li",[o("p",[n._v("否则，如果vnode不是文本节点或注释节点")]),n._v(" "),o("ul",[o("li",[n._v("如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行updateChildren")]),n._v(" "),o("li",[n._v("如果只有oldVnode有子节点，那就把这些节点都删除")]),n._v(" "),o("li",[n._v("如果只有vnode有子节点，那就创建这些子节点")]),n._v(" "),o("li",[n._v("如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串")])])]),n._v(" "),o("li",[o("p",[n._v("如果vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以")])])]),n._v(" "),o("p",[n._v("代码如下：")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    // 如果新旧节点一致，什么都不做\n    if (oldVnode === vnode) {\n      return\n    }\n\n    // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化\n    const elm = vnode.elm = oldVnode.elm\n\n    // 异步占位符\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)\n      } else {\n        vnode.isAsyncPlaceholder = true\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    // 如果新旧都是静态节点，并且具有相同的key\n    // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上\n    // 也不用再有其他操作\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance\n      return\n    }\n\n    let i\n    const data = vnode.data\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode)\n    }\n\n    const oldCh = oldVnode.children\n    const ch = vnode.children\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n      if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)\n    }\n    // 如果vnode不是文本节点或者注释节点\n    if (isUndef(vnode.text)) {\n      // 并且都有子节点\n      if (isDef(oldCh) && isDef(ch)) {\n        // 并且子节点不完全一致，则调用updateChildren\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n\n        // 如果只有新的vnode有子节点\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n        // elm已经引用了老的dom节点，在老的dom节点上添加子节点\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n\n        // 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n\n        // 如果老节点是文本节点\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '')\n      }\n\n      // 如果新vnode和老vnode是文本节点或注释节点\n      // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text)\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)\n    }\n  }\n")])])]),o("h2",{attrs:{id:"_5-updatachildren原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-updatachildren原理"}},[n._v("#")]),n._v(" 5.updataChildren原理")]),n._v(" "),o("hr"),n._v(" "),o("h3",{attrs:{id:"updatechildren的逻辑是："}},[o("a",{staticClass:"header-anchor",attrs:{href:"#updatechildren的逻辑是："}},[n._v("#")]),n._v(" updateChildren的逻辑是：")]),n._v(" "),o("ol",[o("li",[n._v("分别获取oldVnode和vnode的firstChild、lastChild，赋值给oldStartVnode、oldEndVnode、newStartVnode、newEndVnode")]),n._v(" "),o("li",[n._v("如果oldStartVnode和newStartVnode是同一节点，调用patchVnode进行patch，然后将oldStartVnode和newStartVnode都设置为下一个子节点，重复上述流程\n"),o("img",{attrs:{src:"https://images2018.cnblogs.com/blog/1272362/201711/1272362-20171128161117472-1355681854.png",alt:""}})]),n._v(" "),o("li",[n._v("如果oldEndVnode和newEndVnode是同一节点，调用patchVnode进行patch，然后将oldEndVnode和newEndVnode都设置为上一个子节点，重复上述流程\n"),o("img",{attrs:{src:"https://images2018.cnblogs.com/blog/1272362/201711/1272362-20171128161513456-35774165.png",alt:""}})]),n._v(" "),o("li",[n._v("如果oldStartVnode和newEndVnode是同一节点，调用patchVnode进行patch，如果removeOnly是false，那么可以把oldStartVnode.elm移动到oldEndVnode.elm之后，然后把oldStartVnode设置为下一个节点，newEndVnode设置为上一个节点，重复上述流程\n"),o("img",{attrs:{src:"https://images2018.cnblogs.com/blog/1272362/201711/1272362-20171128161959690-1680308559.png",alt:""}})]),n._v(" "),o("li",[n._v("如果newStartVnode和oldEndVnode是同一节点，调用patchVnode进行patch，如果removeOnly是false，那么可以把oldEndVnode.elm移动到oldStartVnode.elm之前，然后把newStartVnode设置为下一个节点，oldEndVnode设置为上一个节点，重复上述流程\n"),o("img",{attrs:{src:"https://images2018.cnblogs.com/blog/1272362/201711/1272362-20171128162402050-1780204197.png",alt:""}})]),n._v(" "),o("li",[n._v("如果以上都不匹配，就尝试在oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点")]),n._v(" "),o("li",[n._v("如果上一步找到了跟newStartVnode相同key的节点，那么通过其他属性的比较来判断这2个节点是否是同一个节点，如果是，就调用patchVnode进行patch，如果removeOnly是false，就把newStartVnode.elm插入到oldStartVnode.elm之前，把newStartVnode设置为下一个节点，重复上述流程\n"),o("img",{attrs:{src:"https://images2018.cnblogs.com/blog/1272362/201711/1272362-20171128162610253-1637696428.png",alt:""}})]),n._v(" "),o("li",[n._v("如果在oldChildren中没有寻找到newStartVnode的同一节点，那就创建一个新节点，把newStartVnode设置为下一个节点，重复上述流程")]),n._v(" "),o("li",[n._v("如果oldStartVnode跟oldEndVnode重合了，并且newStartVnode跟newEndVnode也重合了，这个循环就结束了")])]),n._v(" "),o("p",[n._v("具体代码如下：")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0 // 旧头索引\n    let newStartIdx = 0 // 新头索引\n    let oldEndIdx = oldCh.length - 1 // 旧尾索引\n    let newEndIdx = newCh.length - 1 // 新尾索引\n    let oldStartVnode = oldCh[0] // oldVnode的第一个child\n    let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child\n    let newStartVnode = newCh[0] // newVnode的第一个child\n    let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      // 如果oldVnode的第一个child不存在\n      if (isUndef(oldStartVnode)) {\n        // oldStart索引右移\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n\n      // 如果oldVnode的最后一个child不存在\n      } else if (isUndef(oldEndVnode)) {\n        // oldEnd索引左移\n        oldEndVnode = oldCh[--oldEndIdx]\n\n      // oldStartVnode和newStartVnode是同一个节点\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        // patch oldStartVnode和newStartVnode， 索引左移，继续循环\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n\n      // oldEndVnode和newEndVnode是同一个节点\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        // patch oldEndVnode和newEndVnode，索引右移，继续循环\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n\n      // oldStartVnode和newEndVnode是同一个节点\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        // patch oldStartVnode和newEndVnode\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        // oldStart索引右移，newEnd索引左移\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n\n      // 如果oldEndVnode和newStartVnode是同一个节点\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        // patch oldEndVnode和newStartVnode\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        // oldEnd索引左移，newStart索引右移\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n\n      // 如果都不匹配\n      } else {\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n\n        // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n\n        // 如果未找到，说明newStartVnode是一个新的节点\n        if (isUndef(idxInOld)) { // New element\n          // 创建一个新Vnode\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n\n        // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !vnodeToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            )\n          }\n\n          // 比较两个具有相同的key的新节点是否是同一个节点\n          //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            // patch vnodeToMove和newStartVnode\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n            // 清除\n            oldCh[idxInOld] = undefined\n            // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm\n            // 移动到oldStartVnode.elm之前\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n\n          // 如果key相同，但是节点不相同，则创建一个新的节点\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          }\n        }\n\n        // 右移\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n")])])]),o("h2",{attrs:{id:"_6-具体的diff分析"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_6-具体的diff分析"}},[n._v("#")]),n._v(" 6.具体的Diff分析")]),n._v(" "),o("hr"),n._v(" "),o("p",[n._v("不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。")]),n._v(" "),o("p",[n._v("diff的遍历过程中，只要是对dom进行的操作都调用api.insertBefore，api.insertBefore只是原生insertBefore的简单封装。\n比较分为两种，一种是有vnode.key的，一种是没有的。但这两种比较对真实dom的操作是一致的。")]),n._v(" "),o("p",[n._v("对于与sameVnode(oldStartVnode, newStartVnode)和sameVnode(oldEndVnode,newEndVnode)为true的情况，不需要对dom进行移动。")]),n._v(" "),o("p",[n._v("总结遍历过程，有3种dom操作：上述图中都有")]),n._v(" "),o("ol",[o("li",[n._v("当oldStartVnode，newEndVnode值得比较，说明oldStartVnode.el跑到oldEndVnode.el的后边了。")]),n._v(" "),o("li",[n._v("当oldEndVnode，newStartVnode值得比较，oldEndVnode.el跑到了oldStartVnode.el的前边，准确的说应该是oldEndVnode.el需要移动到oldStartVnode.el的前边”。")]),n._v(" "),o("li",[n._v("newCh中的节点oldCh里没有， 将新节点插入到oldStartVnode.el的前边")])]),n._v(" "),o("p",[n._v("在结束时，分为两种情况：")]),n._v(" "),o("ol",[o("li",[n._v("oldStartIdx > oldEndIdx，可以认为oldCh先遍历完。当然也有可能newCh此时也正好完成了遍历，统一都归为此类。此时newStartIdx和newEndIdx之间的vnode是新增的，调用addVnodes，把他们全部插进before的后边，before很多时候是为null的。addVnodes调用的是insertBefore操作dom节点，我们看看insertBefore的文档：parentElement.insertBefore(newElement, referenceElement)\n如果referenceElement为null则newElement将被插入到子节点的末尾。如果newElement已经在DOM树中，newElement首先会从DOM树中移除。所以before为null，newElement将被插入到子节点的末尾。")]),n._v(" "),o("li",[n._v("newStartIdx > newEndIdx，可以认为newCh先遍历完。此时oldStartIdx和oldEndIdx之间的vnode在新的子节点里已经不存在了，调用removeVnodes将它们从dom里删除")])])])}),[],!1,null,null,null);e.default=t.exports}}]);