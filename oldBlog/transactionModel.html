<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事务模型 | Niko&#39;s blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="自我驱动～">
    <link rel="preload" href="/assets/css/0.styles.e7705c3d.css" as="style"><link rel="preload" href="/assets/js/app.c4d916ef.js" as="script"><link rel="preload" href="/assets/js/2.7b65586e.js" as="script"><link rel="preload" href="/assets/js/28.4e1c4d5e.js" as="script"><link rel="prefetch" href="/assets/js/10.fe52b0c7.js"><link rel="prefetch" href="/assets/js/11.1ea010e8.js"><link rel="prefetch" href="/assets/js/12.4fad5f4d.js"><link rel="prefetch" href="/assets/js/13.b30c5e9b.js"><link rel="prefetch" href="/assets/js/14.3d89860c.js"><link rel="prefetch" href="/assets/js/15.1093c3a5.js"><link rel="prefetch" href="/assets/js/16.d78dfee6.js"><link rel="prefetch" href="/assets/js/17.e94f74a9.js"><link rel="prefetch" href="/assets/js/18.04933970.js"><link rel="prefetch" href="/assets/js/19.2cfc6a06.js"><link rel="prefetch" href="/assets/js/20.5af1bca2.js"><link rel="prefetch" href="/assets/js/21.deead1cc.js"><link rel="prefetch" href="/assets/js/22.b167ef02.js"><link rel="prefetch" href="/assets/js/23.93287a34.js"><link rel="prefetch" href="/assets/js/24.2a666b39.js"><link rel="prefetch" href="/assets/js/25.079594fc.js"><link rel="prefetch" href="/assets/js/26.d3c406d8.js"><link rel="prefetch" href="/assets/js/27.0a55d4e3.js"><link rel="prefetch" href="/assets/js/29.6ad66f6f.js"><link rel="prefetch" href="/assets/js/3.6982cefd.js"><link rel="prefetch" href="/assets/js/30.7f13756b.js"><link rel="prefetch" href="/assets/js/4.927b536d.js"><link rel="prefetch" href="/assets/js/5.b71571d4.js"><link rel="prefetch" href="/assets/js/6.61e89258.js"><link rel="prefetch" href="/assets/js/7.3c739ce6.js"><link rel="prefetch" href="/assets/js/8.89b308a0.js"><link rel="prefetch" href="/assets/js/9.e0fc39fd.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e7705c3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Niko's blog</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/oldBlog/" class="nav-link router-link-active">
  Old blog
</a></div><div class="nav-item"><a href="https://github.com/Merlin-Liu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/oldBlog/" class="nav-link router-link-active">
  Old blog
</a></div><div class="nav-item"><a href="https://github.com/Merlin-Liu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/oldBlog/BSTmap.html" class="sidebar-link">二叉树的深度优先遍历和广度优先遍历</a></li><li><a href="/oldBlog/BST.html" class="sidebar-link">详细教你实现BST</a></li><li><a href="/oldBlog/functional.html" class="sidebar-link">函数式编程与React高阶组件</a></li><li><a href="/oldBlog/httpCache.html" class="sidebar-link">详解HTTP缓存</a></li><li><a href="/oldBlog/vuediff.html" class="sidebar-link">理解Vue 2.5的Diff算法</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据库事务处理的并发控制技术</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/oldBlog/concurrent.html" class="sidebar-link">并发控制概述</a></li><li><a href="/oldBlog/transactionModel.html" aria-current="page" class="active sidebar-link">事务模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oldBlog/transactionModel.html#_1-事务中的读写操作" class="sidebar-link">1. 事务中的读写操作</a></li><li class="sidebar-sub-header"><a href="/oldBlog/transactionModel.html#_2-事务的原子性" class="sidebar-link">2. 事务的原子性</a></li><li class="sidebar-sub-header"><a href="/oldBlog/transactionModel.html#_3-事务的状态" class="sidebar-link">3. 事务的状态</a></li><li class="sidebar-sub-header"><a href="/oldBlog/transactionModel.html#_4-事务的性质" class="sidebar-link">4. 事务的性质</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础业务</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/oldBlog/setState.html" class="sidebar-link">React的setState分析</a></li><li><a href="/oldBlog/virtualDOM.html" class="sidebar-link">Virtual DOM的简单实现</a></li><li><a href="/oldBlog/css.html" class="sidebar-link">多种方法实现左右固定，中间自适应的CSS布局</a></li><li><a href="/oldBlog/interview.html" class="sidebar-link">2017年10月WEB前端开发实习生面试题总结</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实习生面试题分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redux和React-Redux的实现</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>2018-01-25 13:31，发布于博客园</p> <p><a href="https://www.cnblogs.com/isLiu/p/8350819.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/isLiu/p/8350819.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <p>一个存取或更改数据库的程序的运行成为数据库<strong>事务</strong>，简称事务。事务是数据库应用程序的基本逻辑单位。下面我们详细说事务的操作、状态和状态转换。</p> <h2 id="_1-事务中的读写操作"><a href="#_1-事务中的读写操作" class="header-anchor">#</a> 1. 事务中的读写操作</h2> <hr> <p>在并发控制和数据库恢复技术中，我们只需在数据项和磁盘块的级别上考虑事务中的数据库操作。在这个级别上，事务中的数据库操作只包括以下两个读写操作：</p> <ol><li>READ(X, Y) 读取数据库中的数据项X，存入程序变量Y。</li> <li>WRITE(Y, X) 程序变量Y的值写入数据库中的数据项X。</li></ol> <p>磁盘和主存储器之间的数据交换是以磁盘块为单位进行的。虽然数据项可能是一个数据库记录或更大的数据单位，数据项在多数情况下是数据库记录的一个数据域。</p> <p>READ(X, Y)的实现算法如下：</p> <ol><li>确定包含数据项X的磁盘块的地址A；</li> <li>如果地址为A的数据不在主存缓冲区中，则把A所在磁盘块读入到主存缓冲区；</li> <li>从主存缓冲区找到数据项X，存入程序变量Y。</li></ol> <p>WRITE(Y, X)的实现算法如下：</p> <ol><li>确定包含数据项X的磁盘块地址A；</li> <li>如果地址为A的数据不在主存缓冲区中，则把A所在磁盘块读入到主存缓冲区；</li> <li>把程序变量Y的值存入磁盘块所在的主存缓冲区；</li> <li>立即或以后把包含A磁盘块的缓冲区写到磁盘存储器。</li></ol> <p>任何事务都使用如上定义的READ和WRITE操作读取数据库。</p> <h2 id="_2-事务的原子性"><a href="#_2-事务的原子性" class="header-anchor">#</a> 2. 事务的原子性</h2> <hr> <p>每个事务都必须满足如下的性质：该事务中的所有操作要么全部被成功完成并且这些操作的结果被永久的存储到数据库中，要么这个事务对数据库和其他事务没有任何影响。我们称这种性质为事务的<strong>原子性</strong>。保证事务的原子性是事务处理的重要目的。保证事务原子性的主要方法是“串行化”方法。事务的原子性可能遭到破坏的因素有如下两个：</p> <ol><li>多个事务并发时，不同事务的操作交叉运行。</li> <li>事务在运行中间被强行停止。</li></ol> <p>在第一种情况下，数据库管理系统必须保证多个事务的交叉运行不影响这些事务的原子性。在第二种情况下，数据库系统必须保证被强行终止的事务对数据库和其他事务没有任何影响。</p> <h2 id="_3-事务的状态"><a href="#_3-事务的状态" class="header-anchor">#</a> 3. 事务的状态</h2> <hr> <p>我们需要严格定义事务的“成功完成”等概念。所以必须考虑事务运行过程中的状态变化。一个事务必须处于如下状态之一：</p> <ol><li><strong>活动状态</strong> 事务开始运行就进入活动状态，直到部分提交或失败。</li> <li><strong>部分提交状态</strong> 事务执行完最后一条语句，即执行完END-TRANSACTION命令之后进入部分提交状态。我们下面定义END-TRANSACTION命令。</li> <li><strong>失败状态</strong> 发现一个事务不能正常运行下去时，该事务进入失败状态，数据库管理系统必须消除它对数据库和其他事务的影响。</li> <li><strong>异常结束状态</strong> 当一个失败的事务对数据库和其他事务的影响被消除，数据库恢复到该事务开始执行前的状态以后，该事务退出数据库系统，进入异常结束状态。</li> <li><strong>提交状态</strong> 当一个事务成功完成了所有操作，并且所有操作对数据库的影响都已经永久存入数据库之后，该事务退出数据库系统，进入提交状态，正常结束。</li></ol> <p>我们可以在事务中执行如下的操作来实现事务状态的转换：</p> <ol><li><strong>BEGIN-TRANSACTION</strong> 开始运行事务，使事务进入活动状态。</li> <li><strong>END-TRANSACTION</strong> 说明事务中的所有读写操作都已经完成，使事务进入部分提交状态，把所有操作对数据库的影响存入数据库。</li> <li><strong>COMMIT-TRANSACTION</strong> 标志事务已经成功完成，事务中所有操作对数据库的影响已经安全存入数据库，事务进入提交状态，结束事务的运行。</li> <li><strong>ABORT-TRANSACTION</strong> 标志事务进入失败状态，系统消除事务中所有操作对数据库和其他事务的影响，结束事务的运行。</li></ol> <p>除了以上操作外，有些数据库恢复技术还要求如下的一些操作：</p> <ol><li><strong>UNDO</strong> 消除事务中指定数据操作对数据库的影响。</li> <li><strong>REDO</strong> 重新执行事务中指定数据库操作，保证该操作对数据库的影响能够安全存入数据库。</li></ol> <p>下图给出了事务的状态转换图。一个事务在开始运行之后，立即进入活动状态。当它执行到最后一条语句，即END-TRANSACTION时，进入部分提交状态。此时，事务已经成功完成了它的所有操作。但是该事务的操作对数据库的影响还并没有真正的存入数据库，所以仍然可能失败。而且，并发控制和数据库恢复机制还要对这个事务进行其他方面的检查，确定它是否能够成功地结束。该事务已经满足并发控制和数据库恢复机制的要求，并且它的所有操作对数据库的影响已经安全存入数据库，进入提交状态，成功结束。处于活动状态的事务可能由于某些原因不能继续正常执行，这时，事务将进入失败状态。一个事务进入失败状态后，数据库管理系统首先消除该事务的操作对数据库和其他事务的影响，然后使该事务进入异常结束状态，并完成下述两项任务之一：</p> <ol><li>如果事务的失败是由该事务无关的外部原因引起的，如系统软件错误等，则可重新启动该事务，使之作为一个新的事务开始运行。</li> <li>如果事务的失败是由事务内部的逻辑错误引起的，则该事务的程序有错误，需要重写程序来纠正错误。此时，数据库系统废除失败的事务，并通知用户重写该事务的程序。</li></ol> <p>活动的事务也可以通过ABORT-TRANSACTION操作进入失败状态，终止自身运行。</p> <p><img src="http://images2017.cnblogs.com/blog/1272362/201801/1272362-20180125131659881-825791182.png" alt=""></p> <h2 id="_4-事务的性质"><a href="#_4-事务的性质" class="header-anchor">#</a> 4. 事务的性质</h2> <hr> <p>事务的性质需要数据库管理系统的并发控制和数据库恢复机制来保证。</p> <ol><li><strong>原子性</strong> 事务是数据库系统运行的程序单元。每个事务的操作要么被全部成功执行，要么一个都不被执行。</li> <li><strong>数据库正确保持性</strong> 一个事务的正确执行必须把数据库从一个正确状态转换成另一个正确状态。</li> <li><strong>操作结果永久保持性</strong> 如果一个事务使数据库发生了变化，而且该事务已经进入提交状态，则这些改变不会因为以后的失败而丢失。</li> <li><strong>独立性</strong> 一个事务在进入提交状态之前，它对数据库的更新不可由其他事务读取，这个性质避免了上一篇随笔中说到的临时值问题，也避免了后面将讨论的嵌套回滚处理问题。一般来说，不同的并发控制和数据库恢复方法要求不级别的独立性。</li> <li><strong>可串行性</strong> 并发运行的多个事务的运行效果与这些事务按某种次序顺序执行的效果相同。可串行性是各种并发控制方法所要求的关键性质。</li></ol> <p>保证事务原子性是数据库恢复机制的责任；数据库正确保持性是事务程序设计者的责任；操作结果永久保持性是数据库恢复机制的责任；独立性是数据库恢复机制的责任；可串行性是并发控制机制的责任。</p> <p>事务我们已经详细的说过了，那下次我们就讲事务的调度和事务调度的可串行性。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">7/31/2020, 6:35:42 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c4d916ef.js" defer></script><script src="/assets/js/2.7b65586e.js" defer></script><script src="/assets/js/28.4e1c4d5e.js" defer></script>
  </body>
</html>
