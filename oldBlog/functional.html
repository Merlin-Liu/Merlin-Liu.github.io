<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数式编程与React高阶组件 | Niko&#39;s blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="自我驱动～">
    <link rel="preload" href="/assets/css/0.styles.e7705c3d.css" as="style"><link rel="preload" href="/assets/js/app.c4d916ef.js" as="script"><link rel="preload" href="/assets/js/2.7b65586e.js" as="script"><link rel="preload" href="/assets/js/19.2cfc6a06.js" as="script"><link rel="prefetch" href="/assets/js/10.fe52b0c7.js"><link rel="prefetch" href="/assets/js/11.1ea010e8.js"><link rel="prefetch" href="/assets/js/12.4fad5f4d.js"><link rel="prefetch" href="/assets/js/13.b30c5e9b.js"><link rel="prefetch" href="/assets/js/14.3d89860c.js"><link rel="prefetch" href="/assets/js/15.1093c3a5.js"><link rel="prefetch" href="/assets/js/16.d78dfee6.js"><link rel="prefetch" href="/assets/js/17.e94f74a9.js"><link rel="prefetch" href="/assets/js/18.04933970.js"><link rel="prefetch" href="/assets/js/20.5af1bca2.js"><link rel="prefetch" href="/assets/js/21.deead1cc.js"><link rel="prefetch" href="/assets/js/22.b167ef02.js"><link rel="prefetch" href="/assets/js/23.93287a34.js"><link rel="prefetch" href="/assets/js/24.2a666b39.js"><link rel="prefetch" href="/assets/js/25.079594fc.js"><link rel="prefetch" href="/assets/js/26.d3c406d8.js"><link rel="prefetch" href="/assets/js/27.0a55d4e3.js"><link rel="prefetch" href="/assets/js/28.4e1c4d5e.js"><link rel="prefetch" href="/assets/js/29.6ad66f6f.js"><link rel="prefetch" href="/assets/js/3.6982cefd.js"><link rel="prefetch" href="/assets/js/30.7f13756b.js"><link rel="prefetch" href="/assets/js/4.927b536d.js"><link rel="prefetch" href="/assets/js/5.b71571d4.js"><link rel="prefetch" href="/assets/js/6.61e89258.js"><link rel="prefetch" href="/assets/js/7.3c739ce6.js"><link rel="prefetch" href="/assets/js/8.89b308a0.js"><link rel="prefetch" href="/assets/js/9.e0fc39fd.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e7705c3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Niko's blog</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/oldBlog/" class="nav-link router-link-active">
  Old blog
</a></div><div class="nav-item"><a href="https://github.com/Merlin-Liu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/oldBlog/" class="nav-link router-link-active">
  Old blog
</a></div><div class="nav-item"><a href="https://github.com/Merlin-Liu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/oldBlog/BSTmap.html" class="sidebar-link">二叉树的深度优先遍历和广度优先遍历</a></li><li><a href="/oldBlog/BST.html" class="sidebar-link">详细教你实现BST</a></li><li><a href="/oldBlog/functional.html" aria-current="page" class="active sidebar-link">函数式编程与React高阶组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oldBlog/functional.html#_1-函数式编程" class="sidebar-link">1. 函数式编程</a></li><li class="sidebar-sub-header"><a href="/oldBlog/functional.html#_2-高阶组件" class="sidebar-link">2. 高阶组件</a></li><li class="sidebar-sub-header"><a href="/oldBlog/functional.html#_3-属性代理-props-proxy" class="sidebar-link">3. 属性代理(props proxy)</a></li><li class="sidebar-sub-header"><a href="/oldBlog/functional.html#_4-反向继承" class="sidebar-link">4. 反向继承</a></li></ul></li><li><a href="/oldBlog/httpCache.html" class="sidebar-link">详解HTTP缓存</a></li><li><a href="/oldBlog/vuediff.html" class="sidebar-link">理解Vue 2.5的Diff算法</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库事务处理的并发控制技术</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础业务</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/oldBlog/setState.html" class="sidebar-link">React的setState分析</a></li><li><a href="/oldBlog/virtualDOM.html" class="sidebar-link">Virtual DOM的简单实现</a></li><li><a href="/oldBlog/css.html" class="sidebar-link">多种方法实现左右固定，中间自适应的CSS布局</a></li><li><a href="/oldBlog/interview.html" class="sidebar-link">2017年10月WEB前端开发实习生面试题总结</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实习生面试题分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redux和React-Redux的实现</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>2017-12-26 14:21，发布于博客园</p> <p><a href="https://www.cnblogs.com/isLiu/p/8081393.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/isLiu/p/8081393.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <p>相信不少看过一些框架或者是类库的人都有印象，一个函数叫什么creator或者是什么什么createToFuntion，总是接收一个函数，来返回另一个函数。这是一个高阶函数，它可以接收函数可以当参数，也可以当返回值，这就是函数式编程。像柯里化、装饰器模式、高阶组件，都是相通的，一个道理。</p> <p>本文重点是React高阶组件，要理解高阶组件，不得不说函数式编程。</p> <h2 id="_1-函数式编程"><a href="#_1-函数式编程" class="header-anchor">#</a> 1. 函数式编程</h2> <hr> <p>函数式编程是一种编程模式，在这种编程模式种最常用函数和表达式，函数式编程把函数作为一等公民，强调从函数的角度考虑问题，函数式编程倾向用一系列嵌套的函数来解决问题。</p> <p>简单写个例子</p> <div class="language- extra-class"><pre class="language-text"><code>	function OCaml () {
		console.log('I\'m FP language OCaml')
	}
	function clojure() {
		console.log('I\'m FP language clojure')
	}
</code></pre></div><p>现在想在每条console语句前后各加一条console语句，如果在每个函数都加上console语句，会产生不必要的耦合，所以高阶函数就派上了用场。</p> <div class="language- extra-class"><pre class="language-text"><code>	function FuncWrapper(func) {
		return function () {
			console.log('before')
			func()
			console.log('after')
		}
	}
	var OCaml = FuncWrapper(OCaml)
	var clojure = FuncWrapper(clojure)
</code></pre></div><p>我们写了一个函数FuncWrapper，该函数接一个函数作为参数，将参数函数装饰了一层，返回出去，减少了代码耦合。在设计模式中称这种模式为装饰器或装饰者模式。</p> <p>当然函数式编程的好处不止这一条，有些人吹捧OCaml，clojure, scala等FP语言特性比如：纯函数无副作用、不变的数据、流计算模式、尾递归、柯里化等等。</p> <p>在React中，高阶组件HOC就相当于这么一个FuncWrapper，传入一个组件，返回被包装或者被处理的另一个组件。</p> <h2 id="_2-高阶组件"><a href="#_2-高阶组件" class="header-anchor">#</a> 2. 高阶组件</h2> <hr> <p>上边已经简单说过了什么是高阶组件，其实本质上是一个类工厂。先举个例在再说</p> <p>第一个组件</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export default class OCaml extends React.Component {
  constructor (props) {
    super(props)
    this.changeHandle = this.changeHandle.bind(this)
  }
  changeHandle (value) {
    console.log(value)
  }
  render () {
    return (
        &lt;div&gt;
          &lt;h2&gt;I'm OCaml&lt;/h2&gt;
          &lt;input type=&quot;text&quot; onchange={value =&gt; this.changeHandle(value)}/&gt;
        &lt;/div&gt;
    )
  }
}
</code></pre></div><p>第二个组件</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export default class Clojure extends React.Component {
  constructor (props) {
    super(props)
    this.changeHandle = this.changeHandle.bind(this)
  }
  changeHandle (value) {
    console.log(value)
  }
  render () {
    return (
        &lt;div&gt;
          &lt;h2&gt;I'm Clojure&lt;/h2&gt;
          &lt;input type=&quot;text&quot; onchange={value =&gt; this.changeHandle(value)}/&gt;
        &lt;/div&gt;
    )
  }
}
</code></pre></div><p>有两个不相同的组件，但是有部分功能重合，就是那个changeHandle函数，理解了高阶函数，再解决这类问题就不难了吧？不还是一样吗？</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export default function CompWrapper (Component) {
  return class WarpComponent extends React.Component {
    constructor (props) {
      super(props)
      this.handleChange = this.handleChange.bind(this)
    }

    handleChange (value) {
      console.log(value)
    }

    render () {
      return &lt;Component handleChange={this.handleChange} {...this.props}&gt;&lt;/Component&gt;
    }
  }
}

OCaml = CompWrapper(OCaml)
Clojure = CompWrapper(Clojure)
</code></pre></div><p>这是一个最简单的高阶组件。注意，再高阶组件的返回包装好的组件的时候，我们将高阶组件的props展开并传入包装好的组件中，这是确保给高阶组件的props也能给到被包装的组件上。</p> <p>高阶组件的通途很多，可以用来，代码复用，逻辑抽象，抽离底层代码，渲染劫持，更改state、更改props等等。</p> <p>我们主要说一下两种功能的React高阶组件：属性代理、反向继承。</p> <h2 id="_3-属性代理-props-proxy"><a href="#_3-属性代理-props-proxy" class="header-anchor">#</a> 3. 属性代理(props proxy)</h2> <hr> <p>很好说了，上面已经提到过了，再来一遍，高阶组件将它收到的props传递给被包装的组件，所叫属性代理</p> <div class="language- extra-class"><pre class="language-text"><code>export default function CompWrapper (Component) {
  return class WarpComponent extends React.Component {
    render () {
      return &lt;Component {...this.props}&gt;&lt;/Component&gt;
    }
  }
}
</code></pre></div><h3 id="属性代理主要用来处理以下问题"><a href="#属性代理主要用来处理以下问题" class="header-anchor">#</a> 属性代理主要用来处理以下问题</h3> <ul><li>更改props</li> <li>抽取state</li> <li>通过refs获取组件实例</li> <li>将组件与其他原生DOM包装到一起</li></ul> <h3 id="更改props"><a href="#更改props" class="header-anchor">#</a> 更改props</h3> <p>例子是增加props的，其他的类似，都是在在高阶组件内部加以处理。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export default function CompWrapper (Component) {
  return class WarpComponent extends React.Component {
    say () {
      console.log('我是被高阶组件包装过的组件！')
    }
    newProps = {
      isLogin: true,
      msgList: [1,2,3,4,5]
    }
    render () {
      return &lt;Component say={this.say} {...this.props} {...this.newProps}&gt;&lt;/Component&gt;
    }
  }
}
</code></pre></div><p>包装好的组件可以用this.props.say调用say方法，可以用this.props.isLogin判断登陆状态等等。</p> <h3 id="抽像state"><a href="#抽像state" class="header-anchor">#</a> 抽像state</h3> <p>我们可以通过props和回调函数来抽象state</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export function CompWrapper (Component) {
  return class WarpComponent extends React.Component {
    constructor (props) {
      super(props)
      this.state = {
        inputValue: '暂时还没哟'
      }
      this.changeHandle = this.changeHandle.bind(this)
    }
    changeHandle (event) {
      this.setState({
        inputValue: event.target.value
      })
    }
    render () {
      return &lt;Component {...this.props} inputValue={this.state.inputValue} changeHandle={this.changeHandle}&gt;&lt;/Component&gt;
    }
  }
}
</code></pre></div><p>这个高阶组件将一切数据都绑定到了自己的身上，只需要出触发被包装组件的特定事件，就将改变自己的state，再将自己的state通过props传递给被包装组件。</p> <div class="language- extra-class"><pre class="language-text"><code>@CompWrapper
export class InputComp extends React.Component {
  render () {
    return (
        &lt;div&gt;
          &lt;h2&gt;{this.props.inputValue}&lt;/h2&gt;
          &lt;input type=&quot;text&quot; onChange={this.props.changeHandle}/&gt;
        &lt;/div&gt;
    )
  }
}
</code></pre></div><p>这里的input就成了完全受控的组件。注意：在定义组件的语句上边写上@CompWrapper是和<code>InputComp = CompWrapper(InputComp)</code>作用是一样的。@操作符是ES7的decorator，也就是装饰器。</p> <h3 id="通过-refs-获取组件实例"><a href="#通过-refs-获取组件实例" class="header-anchor">#</a> 通过 refs 获取组件实例</h3> <p>从你的 render 方法中返回你的 UI 结构后，你会发现你想要“伸手”调用从 render 返回的组件实例的方法，我们可以通过ref获取组件的实例，但是想让ref生效，必须先经过一次正常的渲染来使ref得到计算，怎么先让组件经过一次正常的渲染呢？高阶组件又来了，明白了吗？高阶组件的render返回了被包装的组件，然后我们就可以通过ref获取这个组件的实例了。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export function CompWrapper (Component) {
  return class WarpComponent extends React.Component {
    proc(wrappedComponentInstance) {
      wrappedComponentInstance.say()
    }
    render () {
      const props = Object.assign({}, this.props, {ref: this.proc.bind(this)})
      return &lt;Component {...props}&gt;&lt;/Component&gt;
    }
  }
}

@CompWrapper
export class InputComp extends React.Component {
  say () {
    console.log('I\'m InputComp')
  }
  render () {
    return (
        &lt;button onClick={()=&gt;{console.log(this.props)}}&gt;点击&lt;/button&gt;
    )
  }
}
</code></pre></div><p>当被包装的组件被渲染后，就可以执行自己实例的方法了，因为计算ref这件事已经由高阶组件做完了。</p> <h3 id="将组件与其他原生dom包装到一起"><a href="#将组件与其他原生dom包装到一起" class="header-anchor">#</a> 将组件与其他原生DOM包装到一起</h3> <p>这个很好理解，如果想把布局什么的和组件结合到一起，使用高阶组件是一个办法。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export function CompWrapper (Component) {
  return class WarpComponent extends React.Component {
    render () {
      return (
          &lt;div style={{marginTop: 100}}&gt;
            &lt;Component {...this.props}/&gt;
          &lt;/div&gt;
      )
    }
  }
}

</code></pre></div><h2 id="_4-反向继承"><a href="#_4-反向继承" class="header-anchor">#</a> 4. 反向继承</h2> <hr> <p>为什么叫反向继承，是高阶组件继承被包装组件，按照我们想的被包装组件继承高阶组件。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export function CompWrapper (Component) {
  return class WarpComponent extends Component {
    render () {
      return super.render()
    }
  }
}
</code></pre></div><p>反向代理主要用来做<strong>渲染劫持</strong></p> <h3 id="渲染劫持"><a href="#渲染劫持" class="header-anchor">#</a> 渲染劫持</h3> <p>所谓的渲染劫持，就是最后组件所渲染出来的东西或者我们叫React Element完全由高阶组件来决定，通过所以我们可以对任意一个React Element的props进行操作；我们也可以操作React Element的Child。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'

export function CompWrapper (Component) {
  return class WarpComponent extends Component {
    render () {
      const reactElm = super.render()
      let newProps = {}
      if (reactElm.type === 'input') {
        newProps = {value: '这是一个input'}
      }
      const props = Object.assign({}, reactElm.props, newProps)
      const newReactElm = React.cloneElement(reactElm, props, reactElm.props.child)
      return newReactElm
    }
  }
}
</code></pre></div><p>这个例子，判断组件的顶层元素是否为一个input，如果是的话，通过cloneElement这个方法来克隆出一个一样的组件，并将新的props传入，这样input就有值了。</p> <p>用过React-Redux的人可能会有印象，使用connect可以将react和redux关联起来，这里的connect就是一个高阶组件，想到这，就很容易想出connect高阶组件是怎么实现了，我会在写一篇随笔，自己实现一个redux、connect、midlleware还有thunk。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">7/31/2020, 6:35:42 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c4d916ef.js" defer></script><script src="/assets/js/2.7b65586e.js" defer></script><script src="/assets/js/19.2cfc6a06.js" defer></script>
  </body>
</html>
