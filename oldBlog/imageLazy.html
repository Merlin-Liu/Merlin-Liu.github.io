<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>图片懒加载 | Niko&#39;s blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="自我驱动～">
    <link rel="preload" href="/assets/css/0.styles.e7705c3d.css" as="style"><link rel="preload" href="/assets/js/app.c4d916ef.js" as="script"><link rel="preload" href="/assets/js/2.7b65586e.js" as="script"><link rel="preload" href="/assets/js/21.deead1cc.js" as="script"><link rel="prefetch" href="/assets/js/10.fe52b0c7.js"><link rel="prefetch" href="/assets/js/11.1ea010e8.js"><link rel="prefetch" href="/assets/js/12.4fad5f4d.js"><link rel="prefetch" href="/assets/js/13.b30c5e9b.js"><link rel="prefetch" href="/assets/js/14.3d89860c.js"><link rel="prefetch" href="/assets/js/15.1093c3a5.js"><link rel="prefetch" href="/assets/js/16.d78dfee6.js"><link rel="prefetch" href="/assets/js/17.e94f74a9.js"><link rel="prefetch" href="/assets/js/18.04933970.js"><link rel="prefetch" href="/assets/js/19.2cfc6a06.js"><link rel="prefetch" href="/assets/js/20.5af1bca2.js"><link rel="prefetch" href="/assets/js/22.b167ef02.js"><link rel="prefetch" href="/assets/js/23.93287a34.js"><link rel="prefetch" href="/assets/js/24.2a666b39.js"><link rel="prefetch" href="/assets/js/25.079594fc.js"><link rel="prefetch" href="/assets/js/26.d3c406d8.js"><link rel="prefetch" href="/assets/js/27.0a55d4e3.js"><link rel="prefetch" href="/assets/js/28.4e1c4d5e.js"><link rel="prefetch" href="/assets/js/29.6ad66f6f.js"><link rel="prefetch" href="/assets/js/3.6982cefd.js"><link rel="prefetch" href="/assets/js/30.7f13756b.js"><link rel="prefetch" href="/assets/js/4.927b536d.js"><link rel="prefetch" href="/assets/js/5.b71571d4.js"><link rel="prefetch" href="/assets/js/6.61e89258.js"><link rel="prefetch" href="/assets/js/7.3c739ce6.js"><link rel="prefetch" href="/assets/js/8.89b308a0.js"><link rel="prefetch" href="/assets/js/9.e0fc39fd.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e7705c3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Niko's blog</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/oldBlog/" class="nav-link router-link-active">
  Old blog
</a></div><div class="nav-item"><a href="https://github.com/Merlin-Liu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/oldBlog/" class="nav-link router-link-active">
  Old blog
</a></div><div class="nav-item"><a href="https://github.com/Merlin-Liu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  My GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/oldBlog/BSTmap.html" class="sidebar-link">二叉树的深度优先遍历和广度优先遍历</a></li><li><a href="/oldBlog/BST.html" class="sidebar-link">详细教你实现BST</a></li><li><a href="/oldBlog/functional.html" class="sidebar-link">函数式编程与React高阶组件</a></li><li><a href="/oldBlog/httpCache.html" class="sidebar-link">详解HTTP缓存</a></li><li><a href="/oldBlog/vuediff.html" class="sidebar-link">理解Vue 2.5的Diff算法</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库事务处理的并发控制技术</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础业务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/oldBlog/imageLazy.html" aria-current="page" class="active sidebar-link">图片懒加载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oldBlog/imageLazy.html#背景" class="sidebar-link">背景</a></li><li class="sidebar-sub-header"><a href="/oldBlog/imageLazy.html#原理" class="sidebar-link">原理</a></li><li class="sidebar-sub-header"><a href="/oldBlog/imageLazy.html#原生实现" class="sidebar-link">原生实现</a></li><li class="sidebar-sub-header"><a href="/oldBlog/imageLazy.html#zepto插件" class="sidebar-link">zepto插件</a></li></ul></li><li><a href="/oldBlog/sticky.html" class="sidebar-link">滚动到指定位置导航固定（CSS实现）</a></li></ul></section></li><li><a href="/oldBlog/setState.html" class="sidebar-link">React的setState分析</a></li><li><a href="/oldBlog/virtualDOM.html" class="sidebar-link">Virtual DOM的简单实现</a></li><li><a href="/oldBlog/css.html" class="sidebar-link">多种方法实现左右固定，中间自适应的CSS布局</a></li><li><a href="/oldBlog/interview.html" class="sidebar-link">2017年10月WEB前端开发实习生面试题总结</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实习生面试题分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redux和React-Redux的实现</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>2018-04-02 15:05，发布于博客园</p> <p><a href="https://www.cnblogs.com/isLiu/p/8693507.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/isLiu/p/8693507.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <h2 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h2> <p>大部分场景下我们对懒加载的定义实际上是对于图片而言的，对于图片进入可视区域之后去请求图片资源的这种情况、这种case实际上就是一个典型的懒加载的case。这些资源虽然是HTML DOM上的，但是这些资源没有进入可视区域之前，这些图片资源并没有由浏览器发出请求去请求这些图片资源，为什么呢？</p> <p>对于类似电商这种图片很多，页面很长的业务场景下呢，我们希望相关的资源是要进行懒加载的，原因就是<code>首先它能减少无效资源的加载</code>。假如说我们由一张图片，但是用户只看了两页几十张就退出界面了，剩下的绝大部分图片没有进入到用户的可视区域，用户没有去看。这种情况下，我们就没有必要去加载那么多的图片资源的。这些资源对用户访问来说是无效资源，因为他们根本就没看，那么请求这些资源也是无效的请求。</p> <p>第二点就是浏览器对于某一个host name是有并发度上限的，如果说我们的图片所在的CDN和我们的静态资源所在的CDN是同一个CDN的话，我们图片的加载就会阻塞后续JS的加载。JS大部分情况下都是写在body尾部的，那么img大多数情况下会在JS的上面，如果浏览器在并发请求图片的时候达到并发度的限制的话，会导致浏览器没有办法并发请求到后面的JS相关的资源，从而导致网站JS加载的延后，进而<code>影响网站JS相关逻辑的正常使用</code>。</p> <p>图片什么时候会向服务器或者是CDN去请求资源呢，只有img标签里的src属性被设置之后，浏览器在渲染过程中解析到img下的src属性，就会去请求src资源。所以在真实场景下呢，当图片进入可视区域之后，img的src才会被设置进去，而不是说页面一开始加载的时候，可视区之外的img的src属性就被设置进去。如果已经设置了的话，那么显然图片就会被直接的加载进来，也就不存在懒加载的问题了。</p> <h2 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h2> <p>懒加载的实现就是对于没有进入界面可视区域内的图片，img的src并不是这个图片的真正URL，可能是一个1像素的占位符，图片真正的URL被存放在img标签的一个自定义属性上。就先叫data-url吧，因为这个地址没有放到SRC上，所以不会造成img向服务端或者CDN去请求图片资源。当图片通过JS逻辑，可能是监听scroll事件，当scroll事件触发到图片已经进入到界面可视区域内，讲img标签上的data-url属性中的URL地址放置到img的src中，然后src的变化就会触发相关图片的资源请求，这种请求机制是延后的，<code>通过监听scroll事件动态设置src</code>。</p> <h2 id="原生实现"><a href="#原生实现" class="header-anchor">#</a> 原生实现</h2> <p>首先，将图片的src属性置空，将图片的URL放置在img的一个自定义属性<code>data-original</code>中。</p> <p><img src="https://images2018.cnblogs.com/blog/1272362/201804/1272362-20180402140335713-1028384900.png" alt=""></p> <p>实现来说大体的思路就是先获取屏幕的高度和img图片距离屏幕顶端的高度，当图片距离顶端的高度小于屏幕的高度时候，将图片中存储图片URL的属性拿出来赋值给src就可以了。</p> <div class="language- extra-class"><pre class="language-text"><code>var viewHeight = document.documentElement.clientHeight

function lazyload () {
  var eles = document.querySelectorAll('img[data-original][lazyload]')
  Array.prototype.forEach.call(eles, function (item, index) {
    var rect
    if (item.dataset.original === '')
      return
    rect = item.getBoundingClientRect()

    if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) {
      !function () {
        var img = new Image() // 必要的！
        img.src = item.dataset.original
        img.onload = function () {
          item.src = img.src
        }
        item.removeAttribute('data-original')
        item.removeAttribute('lazyload')
      }()
    }
  })
}

lazyload()

document.addEventListener('scroll', lazyload)
</code></pre></div><p>这里要注意的一个点：就是先要执行一下<code>lazyload</code>，否则首屏的几张图片不触发scroll事件是不会被加载出来的。</p> <p>有人把代码粘贴过去试了下，发现图片是乱的，也没有出现什么懒加载。</p> <p><img src="https://images2018.cnblogs.com/blog/1272362/201804/1272362-20180402143606459-2025606641.png" alt=""></p> <p>那是因为我们没有给图片设置高度，图片都以特别矮的高度展现，肯定是集中再首屏了，当然不会出现什么懒加载。</p> <p>加了一下CSS样式。</p> <p><img src="https://images2018.cnblogs.com/blog/1272362/201804/1272362-20180402144037304-1873036564.png" alt=""></p> <p>再次运行看看：</p> <p><img src="https://images2018.cnblogs.com/blog/1272362/201804/1272362-20180402144905776-728770796.gif" alt=""></p> <p>ok效果很明显。</p> <h2 id="zepto插件"><a href="#zepto插件" class="header-anchor">#</a> zepto插件</h2> <p>zepto也有插件实现了lazyload：</p> <div class="language- extra-class"><pre class="language-text"><code>;(function($) {

  function visible(elem){
    elem = $(elem)
    return !!(elem.width() || elem.height()) &amp;&amp; elem.css(&quot;display&quot;) !== &quot;none&quot;
  }

  $.fn.lazyload = function(threshold, callback) {
    // 兼容参数写法
    if($.type(threshold) === 'object') {
      threshold = threshold.threshold;
    }
    if($.type(threshold) === 'function') {
      callback = threshold;
      threshold = 0;
    }
    var $w = $(window),
        th = threshold || 0,
        retina = window.devicePixelRatio &gt; 1,
        attrib = retina? &quot;data-original-retina&quot; : &quot;data-original&quot;,
        images = this,
        loaded;

    this.one(&quot;lazyload&quot;, function() {
      var source = this.getAttribute(attrib);
      source = source || this.getAttribute(&quot;data-original&quot;);
      if (source) {
        this.setAttribute(&quot;src&quot;, source);
        if (typeof callback === &quot;function&quot;) callback(this);
      }
    });

    function lazyload() {
      var inview = images.filter(function() {
        var $e = $(this);
        if (!visible($e)) return;

        var wt = $w.scrollTop(),
            wb = wt + $w.height(),
            et = $e.offset().top,
            eb = et + $e.height();

        return eb &gt;= wt - th &amp;&amp; et &lt;= wb + th;
      });
      // 触发加载
      loaded = inview.trigger(&quot;lazyload&quot;);
      // images剔除已加载的元素
      images = images.not(loaded);
    }

    $w.on(&quot;scroll.lazyload resize.lazyload lookup.lazyload&quot;, lazyload);

    lazyload();

    return this;

  };

})(window.Zepto);
</code></pre></div><p>原理和刚才我说的也差不多，多了很多差错处理还有健壮性的代码，总体思路都是一样的。</p> <p>用法就是先用zepto选择器选择需要进行懒加载的图片，然后执行<code>lazyload</code>方法就可以了，前提是要引入zepto及其懒加载相关的插件。</p> <p><code>$('img[data-original][lazyload]').lazyload()</code></p> <p>具体的演示就不做了，跟上面的一样。</p> <p>如果大家在前端其他框架中使用懒加载，也会有其他的一些工具去支持，不过还是要清楚原理的，在前端轮子这么多的时代，只有特别扎实的HTML、CSS、JS底层基础还有深厚的计算机基础才能在前端的大潮中站稳脚步。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">7/31/2020, 6:35:42 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c4d916ef.js" defer></script><script src="/assets/js/2.7b65586e.js" defer></script><script src="/assets/js/21.deead1cc.js" defer></script>
  </body>
</html>
